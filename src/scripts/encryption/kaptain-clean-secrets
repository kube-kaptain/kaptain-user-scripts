#!/usr/bin/env bash
# SPDX-License-Identifier: MIT
# Copyright (c) 2025-2026 Kaptain contributors (Fred Cooke)
#
# Clean decrypted secrets (.raw and .txt files) from secrets directories.
# Run from repo root.
#
# Usage: kaptain-clean-secrets [--dir DIR] [--dry-run] [--all]
set -euo pipefail

SECRETS_DIR="${SECRETS_DIR:-src/secrets}"
DRY_RUN=false
ALL_PROJECTS=false

usage() {
  echo "Usage: kaptain clean secrets [--dir DIR] [--dry-run] [--all]"
  echo ""
  echo "Remove decrypted secret files (.raw, .txt) from secrets directory."
  echo ""
  echo "Options:"
  echo "  --dir DIR     Secrets directory (default: src/secrets)"
  echo "  --dry-run     Show what would be deleted without deleting"
  echo "  --all         Clean all projects in branchout tree"
  echo "  -h, --help    Show this help"
}

# Find branchout root by walking up from cwd
# Sets BRANCHOUT_ROOT on success, exits on failure
find_branchout_root() {
  local dir="${PWD}"
  local home_projects="${HOME}/projects"

  # Check we're under ~/projects/*/
  if [[ "${dir}" != "${home_projects}/"* ]]; then
    echo "ERROR: Not under ~/projects/, cannot find branchout tree" >&2
    exit 1
  fi

  while [[ "${dir}" != "${home_projects}" && "${dir}" != "/" ]]; do
    if [[ -f "${dir}/Branchoutfile" && -f "${dir}/Branchoutprojects" ]]; then
      BRANCHOUT_ROOT="${dir}"
      return 0
    fi
    dir=$(dirname "${dir}")
  done

  echo "ERROR: Branchout root not found" >&2
  echo "ERROR: Cannot safely perform --all secret cleaning without a valid structure" >&2
  exit 1
}

# Clean all projects in branchout tree
# Uses globals: SECRETS_DIR, DRY_RUN
clean_all_projects() {
  find_branchout_root
  echo "Found branchout root: ${BRANCHOUT_ROOT}"

  # Find all project dirs with secrets - projects are at group/group-project depth
  local project_dirs=()
  while IFS= read -r -d '' dir; do
    project_dirs+=("$dir")
  done < <(find "${BRANCHOUT_ROOT}" -mindepth 4 -maxdepth 4 -type d -path "*/${SECRETS_DIR}" -print0 2>/dev/null | sort -z)

  if [[ ${#project_dirs[@]} -eq 0 ]]; then
    echo ""
    echo "No projects found with ${SECRETS_DIR}"
    exit 0
  fi

  # Extract and display project names (group/project)
  echo ""
  echo "Found ${#project_dirs[@]} project(s) with ${SECRETS_DIR}:"
  echo ""
  local projects=()
  for dir in "${project_dirs[@]}"; do
    # Extract group/project from full path
    local rel_path="${dir#${BRANCHOUT_ROOT}/}"
    local project="${rel_path%/${SECRETS_DIR}}"
    projects+=("${project}")
    echo "  ${project}"
  done

  # Clean each project
  local cleaned=0
  for i in "${!project_dirs[@]}"; do
    local secrets_path="${project_dirs[$i]}"
    local project="${projects[$i]}"
    echo ""
    echo "Cleaning ${SECRETS_DIR} in ${project}:"
    clean_secrets_dir "${secrets_path}"
    cleaned=$((cleaned + 1))
  done

  echo ""
  if [[ "${DRY_RUN}" == "true" ]]; then
    echo "Done. Would clean ${cleaned} project(s)."
  else
    echo "Done. Cleaned ${cleaned} project(s)."
  fi
}

# Clean secrets from a single directory
# Arguments: $1 = secrets directory path
# Uses global: DRY_RUN
clean_secrets_dir() {
  local secrets_dir="$1"

  # Find files to clean
  local raw_files=()
  local txt_files=()

  while IFS= read -r -d '' file; do
    raw_files+=("$file")
  done < <(find "${secrets_dir}" -name "*.raw" -type f -print0 2>/dev/null)

  while IFS= read -r -d '' file; do
    txt_files+=("$file")
  done < <(find "${secrets_dir}" -name "*.txt" -type f -print0 2>/dev/null)

  local total_count=$((${#raw_files[@]} + ${#txt_files[@]}))

  if [[ ${total_count} -eq 0 ]]; then
    echo "No .raw or .txt files found"
    return 0
  fi

  echo "Found ${#raw_files[@]} .raw file(s) and ${#txt_files[@]} .txt file(s)"

  if [[ "${DRY_RUN}" == "true" ]]; then
    echo ""
    echo "Dry run - would delete:"
    if [[ ${#raw_files[@]} -gt 0 ]]; then
      for f in "${raw_files[@]}"; do
        echo "  ${f}"
      done
    fi
    if [[ ${#txt_files[@]} -gt 0 ]]; then
      for f in "${txt_files[@]}"; do
        echo "  ${f}"
      done
    fi
    return 0
  fi

  # Delete files
  local deleted=0
  echo ""
  if [[ ${#raw_files[@]} -gt 0 ]]; then
    for f in "${raw_files[@]}"; do
      echo "Deleting ${f}"
      rm -f "${f}"
      deleted=$((deleted + 1))
    done
  fi
  if [[ ${#txt_files[@]} -gt 0 ]]; then
    for f in "${txt_files[@]}"; do
      echo "Deleting ${f}"
      rm -f "${f}"
      deleted=$((deleted + 1))
    done
  fi
  echo ""

  echo "Deleted ${deleted} file(s)"
}

while [[ $# -gt 0 ]]; do
  case "$1" in
    -h|--help)
      usage
      exit 0
      ;;
    --dir)
      if [[ $# -lt 2 ]]; then
        echo "ERROR: --dir requires a value" >&2
        usage
        exit 1
      fi
      SECRETS_DIR="$2"
      shift 2
      ;;
    --dry-run)
      DRY_RUN=true
      shift
      ;;
    --all)
      ALL_PROJECTS=true
      shift
      ;;
    *)
      echo "ERROR: Unknown option: $1" >&2
      usage
      exit 1
      ;;
  esac
done

# Reject absolute paths for --dir
if [[ "${SECRETS_DIR}" == /* ]]; then
  echo "ERROR: --dir must be a relative path, i.e. a sub path of this repo" >&2
  exit 1
fi

if [[ "${ALL_PROJECTS}" == "true" ]]; then
  clean_all_projects
else
  if [[ ! -d "${SECRETS_DIR}" ]]; then
    echo "ERROR: Secrets directory not found: ${SECRETS_DIR}" >&2
    exit 1
  fi
  clean_secrets_dir "${SECRETS_DIR}"
fi
