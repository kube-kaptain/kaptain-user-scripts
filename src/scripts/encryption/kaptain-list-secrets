#!/usr/bin/env bash
# SPDX-License-Identifier: MIT
# Copyright (c) 2025-2026 Kaptain contributors (Fred Cooke)
#
# List secrets and their encryption status.
# Run from repo root.
#
# Usage: kaptain-list-secrets [--dir DIR] [--all]
set -euo pipefail

SCRIPT_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"
SECRETS_DIR="${SECRETS_DIR:-src/secrets}"
ALL_PROJECTS=false

usage() {
  echo "Usage: kaptain list secrets [--dir DIR] [--all]"
  echo ""
  echo "List secret files and their encryption status."
  echo ""
  echo "Options:"
  echo "  --dir DIR     Secrets directory (default: src/secrets)"
  echo "  --all         List all projects in branchout tree"
  echo "  -h, --help    Show this help"
}

# Discover valid encryption suffixes from available encrypt scripts
discover_enc_suffixes() {
  ENC_SUFFIXES=()
  for script in "${SCRIPT_DIR}"/kaptain-encrypt-*; do
    if [[ -x "${script}" ]]; then
      suffix="${script##*kaptain-encrypt-}"
      ENC_SUFFIXES+=("${suffix}")
    fi
  done
}

# Check if a file extension matches a known enc suffix
is_enc_file() {
  local file="$1"
  local suffix
  for suffix in "${ENC_SUFFIXES[@]}"; do
    if [[ "${file}" == *".${suffix}" ]]; then
      echo "${suffix}"
      return 0
    fi
  done
  return 1
}

# Find branchout root by walking up from cwd
# Sets BRANCHOUT_ROOT on success, exits on failure
find_branchout_root() {
  local dir="${PWD}"
  local home_projects="${HOME}/projects"

  # Check we're under ~/projects/*/
  if [[ "${dir}" != "${home_projects}/"* ]]; then
    echo "ERROR: Not under ~/projects/, cannot find branchout tree" >&2
    exit 1
  fi

  while [[ "${dir}" != "${home_projects}" && "${dir}" != "/" ]]; do
    if [[ -f "${dir}/Branchoutfile" && -f "${dir}/Branchoutprojects" ]]; then
      BRANCHOUT_ROOT="${dir}"
      return 0
    fi
    dir=$(dirname "${dir}")
  done

  echo "ERROR: Branchout root not found" >&2
  echo "ERROR: Cannot perform --all secret listing without a valid structure" >&2
  exit 1
}

# List secrets from a single directory
# Arguments: $1 = secrets directory path
# Updates global counters
list_secrets_dir() {
  local secrets_dir="$1"

  # Arrays for categorizing files
  local raw_pending=()
  local raw_stale=()
  local raw_identical=()
  local txt_exposed=()
  local txt_stale=()
  local txt_identical=()
  local unknown_files=()

  # Parallel array for enc file counts (index matches ENC_SUFFIXES)
  local enc_counts=()
  for ((i=0; i<${#ENC_SUFFIXES[@]}; i++)); do
    enc_counts+=("0")
  done

  # Get all files in secrets dir
  local all_files=()
  while IFS= read -r -d '' file; do
    all_files+=("$file")
  done < <(find "${secrets_dir}" -type f -print0 2>/dev/null)

  if [[ ${#all_files[@]} -eq 0 ]]; then
    echo "No raw or decrypted files found"
    return 0
  fi

  # Process each file
  for file in "${all_files[@]}"; do
    local basename="${file##*/}"

    if [[ "${basename}" == *.raw ]]; then
      # Raw file - find corresponding enc file
      local base="${file%.raw}"
      local found_enc=""
      local enc_time=0

      for suffix in "${ENC_SUFFIXES[@]}"; do
        local enc_file="${base}.${suffix}"
        if [[ -f "${enc_file}" ]]; then
          found_enc="${enc_file}"
          enc_time=$(stat -f %m "${enc_file}" 2>/dev/null || stat -c %Y "${enc_file}" 2>/dev/null)
          break
        fi
      done

      local raw_time
      raw_time=$(stat -f %m "${file}" 2>/dev/null || stat -c %Y "${file}" 2>/dev/null)

      if [[ -z "${found_enc}" ]]; then
        # No enc file exists - pending encryption
        raw_pending+=("${file}")
      elif [[ ${raw_time} -gt ${enc_time} ]]; then
        # Raw newer than enc - pending encryption
        raw_pending+=("${file}")
      elif [[ ${raw_time} -lt ${enc_time} ]]; then
        # Enc newer than raw - stale raw
        raw_stale+=("${file}")
      else
        # Same time - identical/unknown
        raw_identical+=("${file}")
      fi

    elif [[ "${basename}" == *.txt ]]; then
      # Txt file - find corresponding enc file
      local base="${file%.txt}"
      local found_enc=""
      local enc_time=0

      for suffix in "${ENC_SUFFIXES[@]}"; do
        local enc_file="${base}.${suffix}"
        if [[ -f "${enc_file}" ]]; then
          found_enc="${enc_file}"
          enc_time=$(stat -f %m "${enc_file}" 2>/dev/null || stat -c %Y "${enc_file}" 2>/dev/null)
          break
        fi
      done

      if [[ -z "${found_enc}" ]]; then
        # No enc file - this is an orphan txt, treat as unknown
        unknown_files+=("${file}")
        continue
      fi

      local txt_time
      txt_time=$(stat -f %m "${file}" 2>/dev/null || stat -c %Y "${file}" 2>/dev/null)

      if [[ ${txt_time} -gt ${enc_time} ]]; then
        # Txt newer than enc - exposed current
        txt_exposed+=("${file}")
      elif [[ ${txt_time} -lt ${enc_time} ]]; then
        # Enc newer than txt - stale txt
        txt_stale+=("${file}")
      else
        # Same time - identical/unknown
        txt_identical+=("${file}")
      fi

    elif enc_suffix=$(is_enc_file "${file}"); then
      # Valid enc file - count it (find index in ENC_SUFFIXES)
      for ((idx=0; idx<${#ENC_SUFFIXES[@]}; idx++)); do
        if [[ "${ENC_SUFFIXES[$idx]}" == "${enc_suffix}" ]]; then
          enc_counts[$idx]=$((enc_counts[$idx] + 1))
          break
        fi
      done

    else
      # Unknown file type
      unknown_files+=("${file}")
    fi
  done

  # Output results
  local has_output=false

  # Raw files section
  if [[ ${#raw_pending[@]} -gt 0 || ${#raw_stale[@]} -gt 0 || ${#raw_identical[@]} -gt 0 ]]; then
    echo ""
    echo "Raw files:"
    has_output=true

    if [[ ${#raw_pending[@]} -gt 0 ]]; then
      echo "  Pending encryption:"
      for f in "${raw_pending[@]}"; do
        echo "    ${f}"
      done
    fi

    if [[ ${#raw_stale[@]} -gt 0 ]]; then
      echo "  Stale, should remove:"
      for f in "${raw_stale[@]}"; do
        echo "    ${f}"
      done
    fi

    if [[ ${#raw_identical[@]} -gt 0 ]]; then
      echo "  Identical timing, unknown:"
      for f in "${raw_identical[@]}"; do
        echo "    ${f}"
      done
    fi
  fi

  # Txt files section
  if [[ ${#txt_exposed[@]} -gt 0 || ${#txt_stale[@]} -gt 0 || ${#txt_identical[@]} -gt 0 ]]; then
    echo ""
    echo "Decrypted files:"
    has_output=true

    if [[ ${#txt_exposed[@]} -gt 0 ]]; then
      echo "  Exposed current:"
      for f in "${txt_exposed[@]}"; do
        echo "    ${f}"
      done
    fi

    if [[ ${#txt_stale[@]} -gt 0 ]]; then
      echo "  Stale, should remove:"
      for f in "${txt_stale[@]}"; do
        echo "    ${f}"
      done
    fi

    if [[ ${#txt_identical[@]} -gt 0 ]]; then
      echo "  Identical timing, unknown:"
      for f in "${txt_identical[@]}"; do
        echo "    ${f}"
      done
    fi
  fi

  # Unknown files section
  if [[ ${#unknown_files[@]} -gt 0 ]]; then
    echo ""
    echo "Unknown files found:"
    has_output=true
    for f in "${unknown_files[@]}"; do
      echo "  ${f}"
    done
  fi

  if [[ "${has_output}" == "false" ]]; then
    echo "No raw or decrypted files found"
  fi

  # Build summary
  local summary_parts=()
  [[ ${#raw_pending[@]} -gt 0 ]] && summary_parts+=("${#raw_pending[@]} pending encryption")
  [[ ${#raw_stale[@]} -gt 0 ]] && summary_parts+=("${#raw_stale[@]} stale raw")
  [[ ${#raw_identical[@]} -gt 0 ]] && summary_parts+=("${#raw_identical[@]} identical raw")
  [[ ${#txt_exposed[@]} -gt 0 ]] && summary_parts+=("${#txt_exposed[@]} exposed")
  [[ ${#txt_stale[@]} -gt 0 ]] && summary_parts+=("${#txt_stale[@]} stale txt")
  [[ ${#txt_identical[@]} -gt 0 ]] && summary_parts+=("${#txt_identical[@]} identical txt")
  [[ ${#unknown_files[@]} -gt 0 ]] && summary_parts+=("${#unknown_files[@]} unknown")

  # Add enc file counts
  for ((idx=0; idx<${#ENC_SUFFIXES[@]}; idx++)); do
    local count="${enc_counts[$idx]}"
    if [[ ${count} -gt 0 ]]; then
      summary_parts+=("${count} ${ENC_SUFFIXES[$idx]}")
    fi
  done

  if [[ ${#summary_parts[@]} -gt 0 ]]; then
    echo ""
    local IFS=', '
    echo "Summary: ${summary_parts[*]}"
  fi
}

# List all projects in branchout tree
list_all_projects() {
  find_branchout_root
  echo "Found branchout root: ${BRANCHOUT_ROOT}"

  # Find all project dirs with secrets
  local project_dirs=()
  while IFS= read -r -d '' dir; do
    project_dirs+=("$dir")
  done < <(find "${BRANCHOUT_ROOT}" -mindepth 4 -maxdepth 4 -type d -path "*/${SECRETS_DIR}" -print0 2>/dev/null | sort -z)

  if [[ ${#project_dirs[@]} -eq 0 ]]; then
    echo ""
    echo "No projects found with ${SECRETS_DIR}"
    exit 0
  fi

  # Extract and display project names
  echo ""
  echo "Found ${#project_dirs[@]} project(s) with ${SECRETS_DIR}:"
  echo ""
  local projects=()
  for dir in "${project_dirs[@]}"; do
    local rel_path="${dir#${BRANCHOUT_ROOT}/}"
    local project="${rel_path%/${SECRETS_DIR}}"
    projects+=("${project}")
    echo "  ${project}"
  done

  # List each project
  local listed=0
  for i in "${!project_dirs[@]}"; do
    local secrets_path="${project_dirs[$i]}"
    local project="${projects[$i]}"
    echo ""
    echo "Listing ${SECRETS_DIR} in ${project}:"
    list_secrets_dir "${secrets_path}"
    listed=$((listed + 1))
  done

  echo ""
  echo "Done. Listed ${listed} project(s)."
}

# Parse arguments
while [[ $# -gt 0 ]]; do
  case "$1" in
    -h|--help)
      usage
      exit 0
      ;;
    --dir)
      if [[ $# -lt 2 ]]; then
        echo "ERROR: --dir requires a value" >&2
        usage
        exit 1
      fi
      SECRETS_DIR="$2"
      shift 2
      ;;
    --all)
      ALL_PROJECTS=true
      shift
      ;;
    *)
      echo "ERROR: Unknown option: $1" >&2
      usage
      exit 1
      ;;
  esac
done

# Reject absolute paths for --dir
if [[ "${SECRETS_DIR}" == /* ]]; then
  echo "ERROR: --dir must be a relative path, i.e. a sub path of this repo" >&2
  exit 1
fi

# Discover encryption suffixes
discover_enc_suffixes

if [[ "${ALL_PROJECTS}" == "true" ]]; then
  list_all_projects
else
  if [[ ! -d "${SECRETS_DIR}" ]]; then
    echo "ERROR: Secrets directory not found: ${SECRETS_DIR}" >&2
    exit 1
  fi
  echo "Listing secrets in ${SECRETS_DIR}:"
  list_secrets_dir "${SECRETS_DIR}"
fi
